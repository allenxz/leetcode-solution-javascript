##### 967. 连续差相同的数字

返回所有长度为 `N` 且满足其每两个连续位上的数字之间的差的绝对值为 `K` 的**非负整数**。

请注意，**除了**数字 `0` 本身之外，答案中的每个数字都**不能**有前导零。例如，`01` 因为有一个前导零，所以是无效的；但 `0` 是有效的。

你可以按任何顺序返回答案。

 

**示例 1：**

```
输入：N = 3, K = 7
输出：[181,292,707,818,929]
解释：注意，070 不是一个有效的数字，因为它有前导零。
```

**示例 2：**

```
输入：N = 2, K = 1
输出：[10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]
```

 

**提示：**

1. `1 <= N <= 9`
2. `0 <= K <= 9`



##### 解题思路

用普通递归算法去做就行。连回溯都不需要。

首先我们需要定下第一位，因为不能有前导零，所以第一位只能从1~9里面选。有一个例外的情况，就是N=1的时候，返回的数组应该是[0,1,2,3,4,5,6,7,8,9]。特殊处理一下就行。

然后接下来的每一位就加上K，或者减去K递归下去就行。但是需要注意的是，如果K为0的话，加K和减K是没有区别的。这个也得处理一下。



##### 代码

```javascript
/**
 * @param {number} N
 * @param {number} K
 * @return {number[]}
 */
var numsSameConsecDiff = function(N, K) {
    if(N===1)
        return [0,1,2,3,4,5,6,7,8,9];
    let arr=[];
    for(let i=1;i<10;i++){
        find(i,i,N-1);
    }
    return arr;
  	//last->最后一位数字，number->完整的数字，N->还需要加的数字个数
    function find(last,number,N){
        if(N===0)
            arr.push(number);
        else{
            if(last+K<10)
                find(last+K,number*10+last+K,N-1);
            if(K===0)
                return;
            if(last-K>=0)
                find(last-K,number*10+last-K,N-1);
        }
    }
};
```



##### 总结

思路比较清晰简单，关键在处理几个边界条件。

