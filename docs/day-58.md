##### 338. 比特位计数

给定一个非负整数 **num**。对于 **0 ≤ i ≤ num** 范围中的每个数字 **i** ，计算其二进制数中的 1 的数目并将它们作为数组返回。

**示例 1:**

```
输入: 2
输出: [0,1,1]
```

**示例 2:**

```
输入: 5
输出: [0,1,1,2,1,2]
```

**进阶:**

- 给出时间复杂度为**O(n\*sizeof(integer))**的解答非常容易。但你可以在线性时间**O(n)**内用一趟扫描做到吗？
- 要求算法的空间复杂度为**O(n)**。
- 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 **__builtin_popcount**）来执行此操作。



##### 解题思路

这道题主要是用DP+位运算。

首先找DP方程，我们列几个测试用例来找一下规律：

```
数字    比特位数
 0        0
 1        1
 2        1
 3        2
 4        1
```

我们发现，当数字为2的n次方的时候，比特位数为1，这个结合二进制也很好理解。

现在就得找当数字不是2的n次方时的特征，设res[i]为数字i的比特位数：

```
数字    比特位数
 0        0
 1        1
 2        1
 3        2=res[2]+res[1]
 4        1
 5        2=res[4]+res[1]
 6        2=res[4]+res[2]
 7       	3=res[4]+res[3]
 8        1
```

看到这里规律就很明显了：

当数字i不是2的n次方时，res[i]=res[a]+res[b]

a是比i小的最大2的n次方数；b是从1开始递增的正整数，直到i为2的n次方时，重置为1。



求一个数是不是2的n次方，用位运算`i & i-1`比较快，如果是的话其结果为0，否则为1。



##### 代码

```javascript
/**
 * @param {number} num
 * @return {number[]}
 */
var countBits = function(num) {
    let res=new Array(num+1);
    res[0]=0;
    let a,b;
    for(let i=1;i<=num;i++){
        if((i & i-1)===0){
            res[i]=1;
            a=i;
            b=1;
        }
        else{
            res[i]=res[a]+res[b++];
        }
    }
    return res;
};
```



