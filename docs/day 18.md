> 20题是一个栈的简单应用，很简单，就跳过了。然后21和23两道题是类似的题目，不过一道是Easy，一道是Hard，题型差不多，就放在下次一起写。今天写下22。



##### 22. 括号生成

给出 *n* 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且**有效的**括号组合。

例如，给出 *n* = 3，生成结果为：

```
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```



##### 解题思路

从题型分析，这样组合类型多的，每个位置上有多种选择的，用回溯算法就对了。

记住回溯算法的几个要点：

1. 定义递归终点，记录符合情况的组合
2. 处理不符合要求的组合情况
3. 更新子状态，往深处递归
4. 回溯

具体对应写在注释里 ↓↓↓



##### 代码

```javascript
var generateParenthesis = function(n) {
    let res=[];
    backTracking(res,'',0,0,n);
    return res;
};
var backTracking = function(res,tmp,left,right,n){
    //处理不合理的括号组合
    if(left>n||right>n)
        return;
  	//记录符合要求的括号组合
    if(left===n&&right===n)
        res.push(tmp);
    if(left>=right){
      	//要注意的是，这一步相当于更新子状态+回溯。
      	//因为tmp的值在①后并没有发生改变,子状态的更新是通过传值的形式完成的
        backTracking(res,tmp+'(',left+1,right,n);//①
        backTracking(res,tmp+')',left,right+1,n);
    }
}
```



##### 总结

用回溯算法解的题目的特征：

①解数目较多

②每个解的样式一般都是字符串，而字符串中的每一位都有多种可能的选择

至于回溯算法的模板，Day 15有说，就不赘述了。